<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Krokodil-Spiel - Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0a3d0c 0%, #1a5a1c 50%, #0d4a2a 100%);
            color: white;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }

        .score-display {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .score-display h2 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .score-display .size {
            font-size: 2rem;
            font-weight: bold;
            color: #4ade80;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            border: 2px solid #ef4444;
            z-index: 200;
            display: none;
        }

        .game-over.visible {
            display: block;
        }

        .game-over h1 {
            font-size: 2.5rem;
            color: #ef4444;
            margin-bottom: 15px;
        }

        .game-over p {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 25px;
        }

        .restart-btn {
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            pointer-events: auto;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 25px rgba(34, 197, 94, 0.4);
        }

        /* Joystick Controls */
        .joystick-container {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 100;
        }

        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.3);
            position: relative;
            touch-action: none;
        }

        .joystick-stick {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .back-link {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            padding: 12px 25px;
            color: #4ade80;
            text-decoration: none;
            font-weight: 600;
            font-size: 1rem;
            border: 2px solid #4ade80;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }

        .back-link:hover {
            background: #4ade80;
            color: #0a3d0c;
        }

        .win-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            border: 2px solid #4ade80;
            z-index: 200;
            display: none;
        }

        .win-screen.visible {
            display: block;
        }

        .win-screen h1 {
            font-size: 2.5rem;
            color: #4ade80;
            margin-bottom: 15px;
        }

        .instructions {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            font-size: 0.85rem;
            max-width: 200px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .instructions p {
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .instructions .green { color: #4ade80; }
        .instructions .red { color: #ef4444; }

        .team-info {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 10px;
        }

        .team-info h2 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .team-count {
            font-size: 1.1rem;
            font-weight: bold;
            color: #4ade80;
        }

        .egg-control {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            margin-top: 10px;
            pointer-events: auto;
        }

        .egg-control h2 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.7;
            margin-bottom: 8px;
        }

        .offspring-level {
            margin-bottom: 8px;
        }

        .offspring-level label {
            font-size: 0.85rem;
            display: block;
            margin-bottom: 4px;
        }

        .offspring-level input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .offspring-level input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4ade80;
            border-radius: 50%;
            cursor: pointer;
        }

        .egg-cost {
            font-size: 0.85rem;
            color: #fbbf24;
            text-align: center;
            margin-top: 6px;
        }

        .mating-hint {
            font-size: 0.75rem;
            opacity: 0.6;
            text-align: center;
            margin-top: 8px;
            font-style: italic;
        }

        .minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 120px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            .instructions {
                display: none;
            }

            .joystick-base {
                width: 140px;
                height: 140px;
            }

            .joystick-stick {
                width: 60px;
                height: 60px;
            }

            .minimap {
                width: 120px;
                height: 80px;
                bottom: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <div class="score-display">
            <h2>Deine Gr√∂√üe</h2>
            <div class="size" id="sizeDisplay">1.0</div>
        </div>
        <div class="team-info">
            <h2>Dein Team</h2>
            <div class="team-count" id="teamCount">0 Verb√ºndete</div>
        </div>
        <div class="egg-control" id="eggControl">
            <h2>Nachwuchs</h2>
            <div class="offspring-level">
                <label>Start-Level: <span id="offspringLevelDisplay">0.6</span></label>
                <input type="range" id="offspringLevel" min="0.4" max="1.5" step="0.1" value="0.6">
            </div>
            <div class="egg-cost" id="eggCostDisplay">Kostet 0.5 Gr√∂√üe</div>
            <div class="mating-hint">‚ôÄ Fahre in ein ‚ôÇ um ein Ei zu legen</div>
        </div>
    </div>

    <a href="index.html" class="back-link">&larr; Zur√ºck</a>

    <div class="joystick-container">
        <div class="joystick-base" id="joystickBase">
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
    </div>

    <div class="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>

    <div class="game-over" id="gameOver">
        <h1>Gefressen!</h1>
        <p>Ein gr√∂√üeres Krokodil hat dich erwischt.</p>
        <p>Erreichte Gr√∂√üe: <strong id="finalSize">1.0</strong></p>
        <button class="restart-btn" onclick="restartGame()">Nochmal spielen</button>
    </div>

    <div class="win-screen" id="winScreen">
        <h1>Gewonnen!</h1>
        <p>Du bist das gr√∂√üte Krokodil!</p>
        <p>Endgr√∂√üe: <strong id="winSize">1.0</strong></p>
        <button class="restart-btn" onclick="restartGame()">Nochmal spielen</button>
    </div>

    <script>
        // ============================================
        // Krokodil-Spiel - Fressen und Wachsen
        // ============================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const sizeDisplay = document.getElementById('sizeDisplay');
        const gameOverScreen = document.getElementById('gameOver');
        const winScreen = document.getElementById('winScreen');
        const finalSizeDisplay = document.getElementById('finalSize');
        const winSizeDisplay = document.getElementById('winSize');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');

        // Resize canvas to fit window
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Resize minimap
            const minimapContainer = document.querySelector('.minimap');
            minimapCanvas.width = minimapContainer.offsetWidth;
            minimapCanvas.height = minimapContainer.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game Configuration
        const CONFIG = {
            baseSpeed: 3,
            aiSpeedFactor: 0.7,
            growthFactor: 0.15,
            numAICrocs: 15,
            maxAICrocs: 25,
            minSize: 0.5,
            worldPadding: 100,
            worldWidth: 3000,
            worldHeight: 2000,
            spawnInterval: 120,  // frames between spawns
            numEnemyTeams: 3,    // number of enemy teams
            eggBaseCost: 0.3,    // base size cost to lay an egg
            eggHatchTime: 180,   // frames until egg hatches (3 seconds at 60fps)
            minOffspringSize: 0.4,
            maxOffspringSize: 1.5,
            matingCooldown: 120, // frames before can mate again
            // Boids parameters
            swarmSeparationDist: 80,
            swarmAlignmentDist: 150,
            swarmCohesionDist: 200,
            swarmSeparationForce: 0.03,
            swarmAlignmentForce: 0.02,
            swarmCohesionForce: 0.01,
            // Food (fish/frogs) parameters
            maxFood: 20,
            foodSpawnInterval: 60,  // frames between food spawns
            foodGrowth: 0.08,       // size gain from eating food
            // Protection aura parameters
            protectionAuraRadius: 120,
            protectionSizeThreshold: 1.5,  // teammates must be this big to protect
            // Hiding spots parameters
            numHidingSpots: 5,
            hidingSpotRadius: 80,
            maxSizeForHiding: 0.9  // only crocs this size or smaller can hide
        };

        // Team colors
        const TEAM_COLORS = [
            { body: '#4ade80', dark: '#22c55e', name: 'Gr√ºn' },      // Player team (green)
            { body: '#f87171', dark: '#dc2626', name: 'Rot' },       // Enemy team 1 (red)
            { body: '#60a5fa', dark: '#2563eb', name: 'Blau' },      // Enemy team 2 (blue)
            { body: '#fbbf24', dark: '#d97706', name: 'Gelb' }       // Enemy team 3 (yellow)
        ];

        // Game State
        let gameRunning = true;
        let player = null;
        let aiCrocs = [];
        let eggs = [];  // Eggs waiting to hatch
        let food = [];  // Fish and frogs to eat
        let hidingSpots = [];  // Safe zones for small crocs
        let joystickInput = { x: 0, y: 0 };
        let keyboardInput = { x: 0, y: 0 };
        let camera = { x: 0, y: 0 };
        let spawnTimer = 0;
        let foodSpawnTimer = 0;
        let offspringSize = 0.6;  // Selected offspring size
        let matingCooldown = 0;   // Cooldown timer for mating

        // ============================================
        // Crocodile Class
        // ============================================

        class Crocodile {
            constructor(x, y, size, isPlayer = false, teamId = 0, gender = null) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.isPlayer = isPlayer;
                this.teamId = teamId;  // 0 = player team, 1+ = enemy teams
                this.gender = gender || (Math.random() < 0.5 ? 'male' : 'female');  // Random if not specified
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.targetAngle = 0;
                this.alive = true;

                // AI specific
                this.target = null;
                this.fleeTarget = null;
                this.thinkTimer = 0;

                // Swarm behavior vectors
                this.swarmVx = 0;
                this.swarmVy = 0;
            }

            get teamColor() {
                return TEAM_COLORS[this.teamId] || TEAM_COLORS[0];
            }

            get genderSymbol() {
                return this.gender === 'male' ? '‚ôÇ' : '‚ôÄ';
            }

            get radius() {
                return 20 + this.size * 15;
            }

            get speed() {
                const baseSpeed = this.isPlayer ? CONFIG.baseSpeed : CONFIG.baseSpeed * CONFIG.aiSpeedFactor;
                // Bigger = faster (size multiplier: 0.8 at size 0, scales up with size)
                return baseSpeed * (0.8 + this.size * 0.15);
            }

            update(inputX, inputY) {
                if (!this.alive) return;

                // Movement
                if (this.isPlayer) {
                    this.vx = inputX * this.speed;
                    this.vy = inputY * this.speed;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Boundary check (world bounds)
                const padding = this.radius;
                this.x = Math.max(padding, Math.min(CONFIG.worldWidth - padding, this.x));
                this.y = Math.max(padding, Math.min(CONFIG.worldHeight - padding, this.y));

                // Update angle based on velocity
                if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                    this.targetAngle = Math.atan2(this.vy, this.vx);
                }

                // Smooth angle rotation
                let angleDiff = this.targetAngle - this.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                this.angle += angleDiff * 0.15;
            }

            // Calculate swarm behavior forces (Boids algorithm)
            calculateSwarmBehavior(teammates) {
                let separationX = 0, separationY = 0;
                let alignmentX = 0, alignmentY = 0;
                let cohesionX = 0, cohesionY = 0;
                let separationCount = 0, alignmentCount = 0, cohesionCount = 0;

                for (const mate of teammates) {
                    if (mate === this || !mate.alive) continue;

                    const dx = mate.x - this.x;
                    const dy = mate.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Separation: steer away from nearby teammates
                    if (dist < CONFIG.swarmSeparationDist && dist > 0) {
                        separationX -= dx / dist;
                        separationY -= dy / dist;
                        separationCount++;
                    }

                    // Alignment: match velocity of nearby teammates
                    if (dist < CONFIG.swarmAlignmentDist) {
                        alignmentX += mate.vx;
                        alignmentY += mate.vy;
                        alignmentCount++;
                    }

                    // Cohesion: move towards center of nearby teammates
                    if (dist < CONFIG.swarmCohesionDist) {
                        cohesionX += mate.x;
                        cohesionY += mate.y;
                        cohesionCount++;
                    }
                }

                // Average and apply forces
                this.swarmVx = 0;
                this.swarmVy = 0;

                if (separationCount > 0) {
                    this.swarmVx += (separationX / separationCount) * CONFIG.swarmSeparationForce;
                    this.swarmVy += (separationY / separationCount) * CONFIG.swarmSeparationForce;
                }

                if (alignmentCount > 0) {
                    const avgVx = alignmentX / alignmentCount;
                    const avgVy = alignmentY / alignmentCount;
                    this.swarmVx += (avgVx - this.vx) * CONFIG.swarmAlignmentForce;
                    this.swarmVy += (avgVy - this.vy) * CONFIG.swarmAlignmentForce;
                }

                if (cohesionCount > 0) {
                    const centerX = cohesionX / cohesionCount;
                    const centerY = cohesionY / cohesionCount;
                    const toCenterX = centerX - this.x;
                    const toCenterY = centerY - this.y;
                    const toCenterDist = Math.sqrt(toCenterX * toCenterX + toCenterY * toCenterY);
                    if (toCenterDist > 0) {
                        this.swarmVx += (toCenterX / toCenterDist) * CONFIG.swarmCohesionForce;
                        this.swarmVy += (toCenterY / toCenterDist) * CONFIG.swarmCohesionForce;
                    }
                }
            }

            updateAI(allCrocs, teammates) {
                if (!this.alive) return;

                this.thinkTimer--;
                if (this.thinkTimer <= 0) {
                    this.thinkTimer = 30 + Math.random() * 30;
                    this.chooseTarget(allCrocs);
                }

                // Calculate swarm behavior with teammates
                this.calculateSwarmBehavior(teammates);

                // Move towards target or flee
                let targetX = 0, targetY = 0;

                if (this.fleeTarget && this.fleeTarget.alive) {
                    // Flee from bigger croc (from different team)
                    const dx = this.x - this.fleeTarget.x;
                    const dy = this.y - this.fleeTarget.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        targetX = dx / dist;
                        targetY = dy / dist;
                    }
                } else if (this.target && this.target.alive) {
                    // Chase smaller croc (from different team)
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        targetX = dx / dist;
                        targetY = dy / dist;
                    }
                } else {
                    // Wander randomly with swarm influence
                    targetX = Math.cos(this.angle);
                    targetY = Math.sin(this.angle);
                }

                // Combine target direction with swarm behavior
                this.vx = targetX * this.speed + this.swarmVx * this.speed;
                this.vy = targetY * this.speed + this.swarmVy * this.speed;

                // Normalize if too fast
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > this.speed * 1.2) {
                    this.vx = (this.vx / currentSpeed) * this.speed * 1.2;
                    this.vy = (this.vy / currentSpeed) * this.speed * 1.2;
                }

                this.update(0, 0);
            }

            chooseTarget(allCrocs) {
                this.target = null;
                this.fleeTarget = null;

                let closestPrey = null;
                let closestPreyDist = Infinity;
                let closestThreat = null;
                let closestThreatDist = Infinity;

                for (const croc of allCrocs) {
                    if (croc === this || !croc.alive) continue;

                    // Skip teammates - can't eat or be eaten by same team
                    if (croc.teamId === this.teamId) continue;

                    const dx = croc.x - this.x;
                    const dy = croc.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (croc.size < this.size - 0.1) {
                        // Potential prey (from another team)
                        if (dist < closestPreyDist) {
                            closestPreyDist = dist;
                            closestPrey = croc;
                        }
                    } else if (croc.size > this.size + 0.1) {
                        // Potential threat (from another team)
                        if (dist < closestThreatDist && dist < 300) {
                            closestThreatDist = dist;
                            closestThreat = croc;
                        }
                    }
                }

                // Prioritize fleeing if threat is close
                if (closestThreat && closestThreatDist < 200) {
                    this.fleeTarget = closestThreat;
                } else {
                    this.target = closestPrey;
                }
            }

            draw(ctx, camera) {
                if (!this.alive) return;

                // Calculate screen position
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                // Don't draw if off screen
                if (screenX < -150 || screenX > canvas.width + 150 ||
                    screenY < -150 || screenY > canvas.height + 150) {
                    return;
                }

                ctx.save();
                ctx.translate(screenX, screenY);
                ctx.rotate(this.angle);

                const baseSize = this.radius;

                // Determine color based on team
                const colors = this.teamColor;
                let bodyColor = colors.body;
                let darkColor = colors.dark;

                // Body (ellipse)
                ctx.beginPath();
                ctx.ellipse(0, 0, baseSize * 1.3, baseSize * 0.7, 0, 0, Math.PI * 2);
                ctx.fillStyle = bodyColor;
                ctx.fill();
                ctx.strokeStyle = darkColor;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Tail
                ctx.beginPath();
                ctx.moveTo(-baseSize * 1.2, 0);
                ctx.quadraticCurveTo(-baseSize * 1.8, -baseSize * 0.3, -baseSize * 2.2, 0);
                ctx.quadraticCurveTo(-baseSize * 1.8, baseSize * 0.3, -baseSize * 1.2, 0);
                ctx.fillStyle = bodyColor;
                ctx.fill();
                ctx.stroke();

                // Snout
                ctx.beginPath();
                ctx.ellipse(baseSize * 1.1, 0, baseSize * 0.6, baseSize * 0.35, 0, 0, Math.PI * 2);
                ctx.fillStyle = bodyColor;
                ctx.fill();
                ctx.stroke();

                // Eyes
                const eyeY = baseSize * 0.25;
                const eyeX = baseSize * 0.3;

                // Eye whites
                ctx.beginPath();
                ctx.arc(eyeX, -eyeY, baseSize * 0.2, 0, Math.PI * 2);
                ctx.arc(eyeX, eyeY, baseSize * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                // Pupils
                ctx.beginPath();
                ctx.arc(eyeX + baseSize * 0.05, -eyeY, baseSize * 0.1, 0, Math.PI * 2);
                ctx.arc(eyeX + baseSize * 0.05, eyeY, baseSize * 0.1, 0, Math.PI * 2);
                ctx.fillStyle = 'black';
                ctx.fill();

                // Teeth (on snout)
                ctx.fillStyle = 'white';
                for (let i = 0; i < 4; i++) {
                    const tx = baseSize * 1.0 + i * baseSize * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(tx, -baseSize * 0.35);
                    ctx.lineTo(tx + baseSize * 0.05, -baseSize * 0.5);
                    ctx.lineTo(tx + baseSize * 0.1, -baseSize * 0.35);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(tx, baseSize * 0.35);
                    ctx.lineTo(tx + baseSize * 0.05, baseSize * 0.5);
                    ctx.lineTo(tx + baseSize * 0.1, baseSize * 0.35);
                    ctx.fill();
                }

                // Scales pattern
                ctx.strokeStyle = darkColor;
                ctx.lineWidth = 1;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.arc(i * baseSize * 0.3, 0, baseSize * 0.15, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                // Draw size label above crocodile
                ctx.save();
                ctx.translate(screenX, screenY);

                // Size and gender text
                const sizeText = this.genderSymbol + ' ' + this.size.toFixed(1);
                const fontSize = Math.max(12, 10 + this.size * 4);
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                // Text shadow/outline
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText(sizeText, 0, -baseSize - 8);
                ctx.fillText(sizeText, 2, -baseSize - 6);

                // Gender-colored text (pink for female, blue for male)
                ctx.fillStyle = this.gender === 'female' ? '#f472b6' : '#60a5fa';
                ctx.fillText(sizeText, 1, -baseSize - 7);

                ctx.restore();
            }

            grow(amount) {
                this.size += amount;
            }
        }

        // ============================================
        // Egg Class
        // ============================================

        class Egg {
            constructor(x, y, teamId) {
                this.x = x;
                this.y = y;
                this.teamId = teamId;
                this.hatchTimer = CONFIG.eggHatchTime;
                this.hatched = false;
                this.wobble = 0;
            }

            get teamColor() {
                return TEAM_COLORS[this.teamId] || TEAM_COLORS[0];
            }

            update() {
                if (this.hatched) return;

                this.hatchTimer--;
                this.wobble += 0.2;

                if (this.hatchTimer <= 0) {
                    this.hatched = true;
                }
            }

            draw(ctx, camera) {
                if (this.hatched) return;

                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                // Don't draw if off screen
                if (screenX < -50 || screenX > canvas.width + 50 ||
                    screenY < -50 || screenY > canvas.height + 50) {
                    return;
                }

                ctx.save();
                ctx.translate(screenX, screenY);

                // Wobble animation as hatching approaches
                const wobbleAmount = (1 - this.hatchTimer / CONFIG.eggHatchTime) * 0.2;
                ctx.rotate(Math.sin(this.wobble) * wobbleAmount);

                const colors = this.teamColor;

                // Egg shadow
                ctx.beginPath();
                ctx.ellipse(2, 3, 18, 22, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fill();

                // Egg body
                ctx.beginPath();
                ctx.ellipse(0, 0, 16, 20, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#f5f5dc';  // Beige egg color
                ctx.fill();
                ctx.strokeStyle = colors.dark;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Team color spots on egg
                ctx.beginPath();
                ctx.arc(-5, -5, 4, 0, Math.PI * 2);
                ctx.arc(4, 2, 3, 0, Math.PI * 2);
                ctx.arc(-2, 8, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.body;
                ctx.fill();

                // Hatch progress indicator
                const progress = 1 - this.hatchTimer / CONFIG.eggHatchTime;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.floor(progress * 100) + '%', 0, 32);

                ctx.restore();
            }
        }

        // ============================================
        // Food Class (Fish and Frogs)
        // ============================================

        class Food {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.type = Math.random() < 0.6 ? 'fish' : 'frog';
                this.alive = true;
                this.animTimer = Math.random() * Math.PI * 2;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = this.type === 'fish' ? 12 : 10;
            }

            update() {
                if (!this.alive) return;

                this.animTimer += 0.1;

                // Random movement
                if (Math.random() < 0.02) {
                    this.vx = (Math.random() - 0.5) * 1;
                    this.vy = (Math.random() - 0.5) * 1;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Bounce off world edges
                if (this.x < 50 || this.x > CONFIG.worldWidth - 50) this.vx *= -1;
                if (this.y < 50 || this.y > CONFIG.worldHeight - 50) this.vy *= -1;

                this.x = Math.max(50, Math.min(CONFIG.worldWidth - 50, this.x));
                this.y = Math.max(50, Math.min(CONFIG.worldHeight - 50, this.y));
            }

            draw(ctx, camera) {
                if (!this.alive) return;

                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                if (screenX < -30 || screenX > canvas.width + 30 ||
                    screenY < -30 || screenY > canvas.height + 30) {
                    return;
                }

                ctx.save();
                ctx.translate(screenX, screenY);

                if (this.type === 'fish') {
                    // Swimming animation
                    const wobble = Math.sin(this.animTimer * 2) * 0.2;
                    ctx.rotate(Math.atan2(this.vy, this.vx) + wobble);

                    // Fish body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 12, 6, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#60a5fa';
                    ctx.fill();
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Tail
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-16, -5);
                    ctx.lineTo(-16, 5);
                    ctx.closePath();
                    ctx.fill();

                    // Eye
                    ctx.beginPath();
                    ctx.arc(6, -1, 2, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(6.5, -1, 1, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();
                } else {
                    // Frog - hopping animation
                    const hop = Math.abs(Math.sin(this.animTimer)) * 3;
                    ctx.translate(0, -hop);

                    // Body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 8, 6, 0, 0, Math.PI * 2);
                    ctx.fillStyle = '#84cc16';
                    ctx.fill();
                    ctx.strokeStyle = '#65a30d';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Eyes
                    ctx.beginPath();
                    ctx.arc(-3, -5, 3, 0, Math.PI * 2);
                    ctx.arc(3, -5, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#84cc16';
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(-3, -5, 1.5, 0, Math.PI * 2);
                    ctx.arc(3, -5, 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'black';
                    ctx.fill();

                    // Legs
                    ctx.strokeStyle = '#65a30d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-6, 3);
                    ctx.lineTo(-10, 6);
                    ctx.moveTo(6, 3);
                    ctx.lineTo(10, 6);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        // ============================================
        // Hiding Spot Class
        // ============================================

        class HidingSpot {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = CONFIG.hidingSpotRadius;
                this.animTimer = Math.random() * Math.PI * 2;
            }

            // Check if a crocodile is inside and small enough
            canHide(croc) {
                if (croc.size > CONFIG.maxSizeForHiding) return false;

                const dx = croc.x - this.x;
                const dy = croc.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                return dist < this.radius;
            }

            draw(ctx, camera) {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                if (screenX < -this.radius * 2 || screenX > canvas.width + this.radius * 2 ||
                    screenY < -this.radius * 2 || screenY > canvas.height + this.radius * 2) {
                    return;
                }

                this.animTimer += 0.02;

                ctx.save();
                ctx.translate(screenX, screenY);

                // Lily pads / reeds cluster
                ctx.globalAlpha = 0.8;

                // Draw several lily pads
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 + this.animTimer * 0.1;
                    const dist = 20 + i * 10;
                    const lx = Math.cos(angle) * dist;
                    const ly = Math.sin(angle) * dist;
                    const size = 20 + Math.sin(this.animTimer + i) * 3;

                    // Lily pad
                    ctx.beginPath();
                    ctx.ellipse(lx, ly, size, size * 0.7, angle, 0, Math.PI * 2);
                    ctx.fillStyle = '#166534';
                    ctx.fill();
                    ctx.strokeStyle = '#14532d';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Notch in lily pad
                    ctx.beginPath();
                    ctx.moveTo(lx, ly);
                    ctx.lineTo(lx + Math.cos(angle) * size, ly + Math.sin(angle) * size * 0.7);
                    ctx.strokeStyle = '#0d3320';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Center area indicator
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üåø Versteck', 0, this.radius + 15);
                ctx.fillText(`(max ${CONFIG.maxSizeForHiding})`, 0, this.radius + 27);

                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // ============================================
        // Protection Helper Functions
        // ============================================

        // Check if a crocodile is protected by a larger teammate
        function isProtectedByTeammate(croc, allCrocs) {
            for (const mate of allCrocs) {
                if (mate === croc || !mate.alive) continue;
                if (mate.teamId !== croc.teamId) continue;

                // Teammate must be significantly larger
                if (mate.size < CONFIG.protectionSizeThreshold) continue;
                if (mate.size <= croc.size) continue;

                const dx = mate.x - croc.x;
                const dy = mate.y - croc.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < CONFIG.protectionAuraRadius) {
                    return mate;  // Return the protector
                }
            }
            return null;
        }

        // Check if a crocodile is hiding
        function isHiding(croc) {
            for (const spot of hidingSpots) {
                if (spot.canHide(croc)) {
                    return true;
                }
            }
            return false;
        }

        // ============================================
        // Collision Detection
        // ============================================

        function checkCollisions() {
            const allCrocs = [player, ...aiCrocs].filter(c => c.alive);

            // Check crocodile vs crocodile collisions
            for (let i = 0; i < allCrocs.length; i++) {
                for (let j = i + 1; j < allCrocs.length; j++) {
                    const a = allCrocs[i];
                    const b = allCrocs[j];

                    // Same team crocodiles can't eat each other
                    if (a.teamId === b.teamId) continue;

                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (a.radius + b.radius) * 0.7;

                    if (dist < minDist) {
                        // Collision! Bigger eats smaller
                        const sizeDiff = a.size - b.size;

                        if (Math.abs(sizeDiff) > 0.01) {
                            // Determine who would be eaten
                            const predator = sizeDiff > 0 ? a : b;
                            const prey = sizeDiff > 0 ? b : a;

                            // Check if prey is protected
                            const isPreyHiding = isHiding(prey);
                            const protector = isProtectedByTeammate(prey, allCrocs);

                            if (isPreyHiding) {
                                // Prey is hiding - can't be eaten!
                                continue;
                            }

                            if (protector) {
                                // Prey is protected by teammate - can't be eaten!
                                continue;
                            }

                            // Predator eats prey
                            predator.grow(prey.size * CONFIG.growthFactor);
                            prey.alive = false;

                            if (prey.isPlayer) {
                                endGame(false);
                            }
                        }
                    }
                }
            }

            // Check crocodile vs food collisions
            for (const croc of allCrocs) {
                for (const f of food) {
                    if (!f.alive) continue;

                    const dx = croc.x - f.x;
                    const dy = croc.y - f.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < croc.radius + f.radius) {
                        // Eat the food!
                        croc.grow(CONFIG.foodGrowth);
                        f.alive = false;
                    }
                }
            }
        }

        // ============================================
        // Game Loop
        // ============================================

        function initGame() {
            // Create player in center of world (team 0 = player team, female)
            player = new Crocodile(
                CONFIG.worldWidth / 2,
                CONFIG.worldHeight / 2,
                1.0,
                true,
                0,      // Player team
                'female' // Player is always female
            );

            // Create AI crocodiles - distributed among enemy teams and player team
            aiCrocs = [];
            eggs = [];
            food = [];
            hidingSpots = [];
            foodSpawnTimer = 0;
            matingCooldown = 0;
            offspringSize = 0.6;

            // Create hiding spots scattered around the world
            for (let i = 0; i < CONFIG.numHidingSpots; i++) {
                const x = 200 + Math.random() * (CONFIG.worldWidth - 400);
                const y = 200 + Math.random() * (CONFIG.worldHeight - 400);
                hidingSpots.push(new HidingSpot(x, y));
            }

            // Create initial food
            for (let i = 0; i < CONFIG.maxFood / 2; i++) {
                const x = 100 + Math.random() * (CONFIG.worldWidth - 200);
                const y = 100 + Math.random() * (CONFIG.worldHeight - 200);
                food.push(new Food(x, y));
            }

            // Create some initial player team allies (mix of males and females, at least 2 males)
            const allyGenders = ['male', 'male', 'female'];  // Ensure some males for mating
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const dist = 150 + Math.random() * 100;
                const x = player.x + Math.cos(angle) * dist;
                const y = player.y + Math.sin(angle) * dist;
                const size = 0.7 + Math.random() * 0.3;
                aiCrocs.push(new Crocodile(x, y, size, false, 0, allyGenders[i]));
            }

            // Create enemy team crocodiles
            for (let i = 0; i < CONFIG.numAICrocs; i++) {
                const x = CONFIG.worldPadding + Math.random() * (CONFIG.worldWidth - CONFIG.worldPadding * 2);
                const y = CONFIG.worldPadding + Math.random() * (CONFIG.worldHeight - CONFIG.worldPadding * 2);
                // Small random variation: 0.9 to 1.1
                const size = 0.9 + Math.random() * 0.2;
                // Assign to one of the enemy teams (1, 2, or 3)
                const teamId = 1 + (i % CONFIG.numEnemyTeams);

                aiCrocs.push(new Crocodile(x, y, size, false, teamId));
            }

            // Initialize camera
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            gameRunning = true;
            spawnTimer = 0;
            canLayEgg = true;
            gameOverScreen.classList.remove('visible');
            winScreen.classList.remove('visible');
        }

        function spawnNewCroc() {
            // Don't spawn if too many crocs
            const aliveCrocs = aiCrocs.filter(c => c.alive);
            if (aliveCrocs.length >= CONFIG.maxAICrocs) return;

            // Spawn at random edge of world (away from player)
            let x, y;
            const edge = Math.floor(Math.random() * 4);

            switch(edge) {
                case 0: // Top
                    x = Math.random() * CONFIG.worldWidth;
                    y = CONFIG.worldPadding;
                    break;
                case 1: // Right
                    x = CONFIG.worldWidth - CONFIG.worldPadding;
                    y = Math.random() * CONFIG.worldHeight;
                    break;
                case 2: // Bottom
                    x = Math.random() * CONFIG.worldWidth;
                    y = CONFIG.worldHeight - CONFIG.worldPadding;
                    break;
                case 3: // Left
                    x = CONFIG.worldPadding;
                    y = Math.random() * CONFIG.worldHeight;
                    break;
            }

            // Small size: 0.5 to 0.8
            const size = 0.5 + Math.random() * 0.3;

            // Random team (mostly enemy teams, rarely player team)
            const teamId = Math.random() < 0.1 ? 0 : (1 + Math.floor(Math.random() * CONFIG.numEnemyTeams));

            aiCrocs.push(new Crocodile(x, y, size, false, teamId));
        }

        // Calculate egg cost based on offspring size
        function getEggCost() {
            return CONFIG.eggBaseCost + (offspringSize - CONFIG.minOffspringSize) * 0.5;
        }

        // Check if player can afford to mate
        function canAffordMating() {
            const cost = getEggCost();
            return player.size >= cost + 0.5;  // Keep minimum size
        }

        // Check for mating when player collides with male teammate
        function checkMating(allCrocs) {
            if (!gameRunning || !player.alive) return;
            if (matingCooldown > 0) return;
            if (!canAffordMating()) return;

            // Find nearby male teammates
            for (const croc of allCrocs) {
                if (croc === player || !croc.alive) continue;
                if (croc.teamId !== player.teamId) continue;
                if (croc.gender !== 'male') continue;

                const dx = croc.x - player.x;
                const dy = croc.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const minDist = (croc.radius + player.radius) * 0.8;

                if (dist < minDist) {
                    // Mating! Create an egg
                    const cost = getEggCost();
                    player.size -= cost;

                    // Create egg at mating location
                    const eggX = (player.x + croc.x) / 2;
                    const eggY = (player.y + croc.y) / 2;

                    const egg = new Egg(eggX, eggY, player.teamId);
                    egg.hatchSize = offspringSize;  // Store the offspring size
                    eggs.push(egg);

                    // Start cooldown
                    matingCooldown = CONFIG.matingCooldown;
                    break;
                }
            }
        }

        // Hatch eggs and spawn new crocodiles
        function updateEggs() {
            for (const egg of eggs) {
                egg.update();

                if (egg.hatched) {
                    // Spawn a new crocodile at egg location with chosen size
                    const hatchSize = egg.hatchSize || offspringSize;
                    const newCroc = new Crocodile(
                        egg.x,
                        egg.y,
                        hatchSize,
                        false,
                        egg.teamId
                    );
                    // Give it initial velocity away from egg
                    newCroc.angle = Math.random() * Math.PI * 2;
                    aiCrocs.push(newCroc);
                }
            }

            // Remove hatched eggs
            eggs = eggs.filter(e => !e.hatched);
        }

        function gameLoop() {
            if (!gameRunning) {
                requestAnimationFrame(gameLoop);
                return;
            }

            // Combine joystick and keyboard input
            const inputX = joystickInput.x || keyboardInput.x;
            const inputY = joystickInput.y || keyboardInput.y;

            // Update player
            player.update(inputX, inputY);

            // Update camera to follow player (smooth)
            const targetCamX = player.x - canvas.width / 2;
            const targetCamY = player.y - canvas.height / 2;
            camera.x += (targetCamX - camera.x) * 0.1;
            camera.y += (targetCamY - camera.y) * 0.1;

            // Clamp camera to world bounds
            camera.x = Math.max(0, Math.min(CONFIG.worldWidth - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(CONFIG.worldHeight - canvas.height, camera.y));

            // Update AI with swarm behavior
            const allCrocs = [player, ...aiCrocs];

            // Group crocodiles by team for swarm behavior
            const teamGroups = {};
            for (const croc of allCrocs) {
                if (!croc.alive) continue;
                if (!teamGroups[croc.teamId]) {
                    teamGroups[croc.teamId] = [];
                }
                teamGroups[croc.teamId].push(croc);
            }

            // Update each AI croc with its teammates
            for (const croc of aiCrocs) {
                const teammates = teamGroups[croc.teamId] || [];
                croc.updateAI(allCrocs, teammates);
            }

            // Update player's teammates for swarm behavior too (they follow player)
            const playerTeammates = teamGroups[0] || [];
            for (const mate of playerTeammates) {
                if (mate !== player && mate.alive) {
                    mate.calculateSwarmBehavior(playerTeammates);
                }
            }

            // Check for mating (female player + male teammate collision)
            checkMating(allCrocs);

            // Update mating cooldown
            if (matingCooldown > 0) matingCooldown--;

            // Check collisions
            checkCollisions();

            // Update eggs
            updateEggs();

            // Update and spawn food
            for (const f of food) {
                f.update();
            }
            food = food.filter(f => f.alive);

            foodSpawnTimer++;
            if (foodSpawnTimer >= CONFIG.foodSpawnInterval && food.length < CONFIG.maxFood) {
                foodSpawnTimer = 0;
                const x = 100 + Math.random() * (CONFIG.worldWidth - 200);
                const y = 100 + Math.random() * (CONFIG.worldHeight - 200);
                food.push(new Food(x, y));
            }

            // Spawn new small crocodiles periodically
            spawnTimer++;
            if (spawnTimer >= CONFIG.spawnInterval) {
                spawnTimer = 0;
                spawnNewCroc();
            }

            // Clean up dead crocodiles
            aiCrocs = aiCrocs.filter(c => c.alive);

            // Clear canvas
            ctx.fillStyle = '#1a5a1c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw water/swamp pattern
            drawBackground();

            // Draw world border
            drawWorldBorder();

            // Draw hiding spots (behind everything)
            for (const spot of hidingSpots) {
                spot.draw(ctx, camera);
            }

            // Draw food
            for (const f of food) {
                f.draw(ctx, camera);
            }

            // Draw eggs
            for (const egg of eggs) {
                egg.draw(ctx, camera);
            }

            // Draw protection auras for teammates
            for (const croc of allCrocs) {
                if (!croc.alive) continue;
                if (croc.size >= CONFIG.protectionSizeThreshold) {
                    // Draw protection aura
                    const screenX = croc.x - camera.x;
                    const screenY = croc.y - camera.y;

                    if (screenX > -200 && screenX < canvas.width + 200 &&
                        screenY > -200 && screenY < canvas.height + 200) {
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, CONFIG.protectionAuraRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(${croc.teamId === 0 ? '74, 222, 128' : '255, 255, 255'}, 0.2)`;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Fill with subtle color
                        ctx.fillStyle = `rgba(${croc.teamId === 0 ? '74, 222, 128' : '255, 255, 255'}, 0.05)`;
                        ctx.fill();
                    }
                }
            }

            // Draw all crocodiles (sorted by size for proper layering)
            const drawOrder = [...allCrocs].filter(c => c.alive).sort((a, b) => a.size - b.size);
            for (const croc of drawOrder) {
                croc.draw(ctx, camera);

                // Draw shield icon if protected
                if (!croc.isPlayer) {
                    const protector = isProtectedByTeammate(croc, allCrocs);
                    const hiding = isHiding(croc);

                    if (protector || hiding) {
                        const screenX = croc.x - camera.x;
                        const screenY = croc.y - camera.y;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(hiding ? 'üåø' : 'üõ°Ô∏è', screenX, screenY - croc.radius - 20);
                    }
                }
            }

            // Draw minimap
            drawMinimap();

            // Update UI
            sizeDisplay.textContent = player.size.toFixed(1);

            // Update team count with male count
            const allies = (teamGroups[0] || []).filter(c => c !== player && c.alive);
            const maleCount = allies.filter(c => c.gender === 'male').length;
            const femaleCount = allies.filter(c => c.gender === 'female').length;
            const eggCount = eggs.filter(e => e.teamId === 0).length;
            document.getElementById('teamCount').textContent =
                `${maleCount}‚ôÇ ${femaleCount}‚ôÄ` + (eggCount > 0 ? ` + ${eggCount}ü•ö` : '');

            // Update offspring cost display
            const cost = getEggCost();
            document.getElementById('eggCostDisplay').textContent =
                `Kostet ${cost.toFixed(1)} Gr√∂√üe` + (canAffordMating() ? '' : ' (zu klein!)');
            document.getElementById('eggCostDisplay').style.color =
                canAffordMating() ? '#4ade80' : '#ef4444';

            // Update mating hint
            const matingHint = document.querySelector('.mating-hint');
            if (matingCooldown > 0) {
                matingHint.textContent = `‚è≥ Warte... (${Math.ceil(matingCooldown / 60)}s)`;
            } else if (!canAffordMating()) {
                matingHint.textContent = '‚ùå Zu klein zum Paaren!';
            } else if (maleCount === 0) {
                matingHint.textContent = '‚ö†Ô∏è Kein ‚ôÇ in deinem Team!';
            } else {
                matingHint.textContent = '‚ôÄ Fahre in ein ‚ôÇ um ein Ei zu legen';
            }

            requestAnimationFrame(gameLoop);
        }

        function drawMinimap() {
            const mw = minimapCanvas.width;
            const mh = minimapCanvas.height;
            const scaleX = mw / CONFIG.worldWidth;
            const scaleY = mh / CONFIG.worldHeight;

            // Clear minimap
            minimapCtx.fillStyle = '#0d2818';
            minimapCtx.fillRect(0, 0, mw, mh);

            // Draw world border
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(0, 0, mw, mh);

            // Draw camera viewport
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            minimapCtx.strokeRect(
                camera.x * scaleX,
                camera.y * scaleY,
                canvas.width * scaleX,
                canvas.height * scaleY
            );

            // Draw hiding spots on minimap
            for (const spot of hidingSpots) {
                const sx = spot.x * scaleX;
                const sy = spot.y * scaleY;
                const sr = spot.radius * scaleX;

                minimapCtx.beginPath();
                minimapCtx.arc(sx, sy, sr, 0, Math.PI * 2);
                minimapCtx.fillStyle = 'rgba(22, 101, 52, 0.5)';
                minimapCtx.fill();
            }

            // Draw food on minimap
            for (const f of food) {
                if (!f.alive) continue;
                const fx = f.x * scaleX;
                const fy = f.y * scaleY;

                minimapCtx.beginPath();
                minimapCtx.arc(fx, fy, 2, 0, Math.PI * 2);
                minimapCtx.fillStyle = f.type === 'fish' ? '#60a5fa' : '#84cc16';
                minimapCtx.fill();
            }

            // Draw eggs on minimap
            for (const egg of eggs) {
                if (egg.hatched) continue;
                const ex = egg.x * scaleX;
                const ey = egg.y * scaleY;

                minimapCtx.beginPath();
                minimapCtx.arc(ex, ey, 3, 0, Math.PI * 2);
                minimapCtx.fillStyle = egg.teamColor.body;
                minimapCtx.globalAlpha = 0.6;
                minimapCtx.fill();
                minimapCtx.globalAlpha = 1;
            }

            // Draw AI crocodiles with team colors
            for (const croc of aiCrocs) {
                if (!croc.alive) continue;
                const mx = croc.x * scaleX;
                const my = croc.y * scaleY;
                const size = Math.max(2, croc.size * 3);

                minimapCtx.beginPath();
                minimapCtx.arc(mx, my, size, 0, Math.PI * 2);
                minimapCtx.fillStyle = croc.teamColor.body;
                minimapCtx.fill();
            }

            // Draw player (highlighted)
            if (player.alive) {
                const px = player.x * scaleX;
                const py = player.y * scaleY;
                const size = Math.max(3, player.size * 3);

                minimapCtx.beginPath();
                minimapCtx.arc(px, py, size + 2, 0, Math.PI * 2);
                minimapCtx.fillStyle = 'white';
                minimapCtx.fill();

                minimapCtx.beginPath();
                minimapCtx.arc(px, py, size, 0, Math.PI * 2);
                minimapCtx.fillStyle = '#22c55e';
                minimapCtx.fill();
            }
        }

        function drawWorldBorder() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 5;
            ctx.strokeRect(-camera.x, -camera.y, CONFIG.worldWidth, CONFIG.worldHeight);
        }

        function drawBackground() {
            // Subtle swamp pattern
            ctx.fillStyle = 'rgba(0, 50, 0, 0.3)';
            for (let i = 0; i < 20; i++) {
                const x = (i * 173 + Date.now() * 0.01) % (canvas.width + 200) - 100;
                const y = (i * 137) % canvas.height;
                ctx.beginPath();
                ctx.ellipse(x, y, 80 + i * 5, 40 + i * 3, i * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Water ripples
            ctx.strokeStyle = 'rgba(100, 200, 150, 0.1)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 10; i++) {
                const x = (i * 251) % canvas.width;
                const y = (i * 197) % canvas.height;
                const size = 30 + Math.sin(Date.now() * 0.002 + i) * 10;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function endGame(won) {
            gameRunning = false;

            if (won) {
                winSizeDisplay.textContent = player.size.toFixed(1);
                winScreen.classList.add('visible');
            } else {
                finalSizeDisplay.textContent = player.size.toFixed(1);
                gameOverScreen.classList.add('visible');
            }
        }

        function restartGame() {
            initGame();
        }

        // ============================================
        // Joystick Controls
        // ============================================

        const joystickBase = document.getElementById('joystickBase');
        const joystickStick = document.getElementById('joystickStick');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };

        function getJoystickCenter() {
            const rect = joystickBase.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function updateJoystick(clientX, clientY) {
            const center = getJoystickCenter();
            const maxDist = joystickBase.offsetWidth / 2 - joystickStick.offsetWidth / 2;

            let dx = clientX - center.x;
            let dy = clientY - center.y;

            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }

            joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

            // Normalize input (-1 to 1)
            joystickInput.x = dx / maxDist;
            joystickInput.y = dy / maxDist;
        }

        function resetJoystick() {
            joystickStick.style.transform = 'translate(-50%, -50%)';
            joystickInput.x = 0;
            joystickInput.y = 0;
        }

        // Touch events
        joystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            updateJoystick(touch.clientX, touch.clientY);
        });

        document.addEventListener('touchmove', (e) => {
            if (!joystickActive) return;
            e.preventDefault();
            const touch = e.touches[0];
            updateJoystick(touch.clientX, touch.clientY);
        }, { passive: false });

        document.addEventListener('touchend', () => {
            joystickActive = false;
            resetJoystick();
        });

        // Mouse events (for desktop testing)
        joystickBase.addEventListener('mousedown', (e) => {
            joystickActive = true;
            updateJoystick(e.clientX, e.clientY);
        });

        document.addEventListener('mousemove', (e) => {
            if (!joystickActive) return;
            updateJoystick(e.clientX, e.clientY);
        });

        document.addEventListener('mouseup', () => {
            joystickActive = false;
            resetJoystick();
        });

        // ============================================
        // Keyboard Controls
        // ============================================

        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            updateKeyboardInput();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            updateKeyboardInput();
        });

        function updateKeyboardInput() {
            keyboardInput.x = 0;
            keyboardInput.y = 0;

            if (keys['ArrowLeft'] || keys['a'] || keys['A']) keyboardInput.x -= 1;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) keyboardInput.x += 1;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) keyboardInput.y -= 1;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) keyboardInput.y += 1;

            // Normalize diagonal movement
            const length = Math.sqrt(keyboardInput.x ** 2 + keyboardInput.y ** 2);
            if (length > 1) {
                keyboardInput.x /= length;
                keyboardInput.y /= length;
            }
        }

        // ============================================
        // Offspring Level Slider
        // ============================================

        const offspringSlider = document.getElementById('offspringLevel');
        const offspringDisplay = document.getElementById('offspringLevelDisplay');

        offspringSlider.addEventListener('input', (e) => {
            offspringSize = parseFloat(e.target.value);
            offspringDisplay.textContent = offspringSize.toFixed(1);
        });

        // ============================================
        // Start Game
        // ============================================

        initGame();
        gameLoop();
    </script>
</body>
</html>
